# CHAPTER 01. 웹과 네트워크의 기본에 대해 알아보자

웹이 어떤 기술로 구성되어 있는지, 그리고 HTTP는 어떻게 탄생했고 성장했는지 살펴보자.

* 웹의 통신 방법
* HTTP의 탄생 및 통신과정
* TCP/IP 통신
* IP, TCP, DNS
* URI & URL

<br>

## 1.1. 웹은 HTTP로 나타낸다

웹 브라우저는 웹 브라우저 주소 입력란에 지정된 URL에 의지해서 웹 서버로부터 리소스 파일 등의 정보를 얻는 것이다.

이때 서버에 파일이 필요하다고 의뢰를 하는 웹 브라우저 등을 클라이언트(Client)라고 부른다.

<br>

![image](https://user-images.githubusercontent.com/43431081/86319253-15b81a00-bc6f-11ea-8645-2b57bcdeac40.png)

이렇게 웹에서는 클라이언트와 서버가  **HTTP(Hyper Transfer Protocol)** 라는 프로토콜(약속)로 통신한다.

<br>

## 1.2. HTTP는 이렇게 태어났고 성장했다

등장한 배경을 알면 HTTP의 목적을 알 수 있기 때문에 배경을 알아보자.

<br>

### 1.2.1. 웹은 지식 공유를 위해 고안되었다.

처음의 WWW는 세계 곳곳에 있는 연구자들의 지식 공유를 지원하기 위해 제안되었다.

* 팀 버너스 리 박사는 멀리 떨어져 있는 동료 연구자와 지식을 공유할 수 있는 시스템을 고안했다.
* 하이퍼텍스트(HyperText)에 의해 여러 문서를 참조할 수 있는 WWW(World Wide Web, 월드 와이드 앱)의 기본 개념을 고안

> **하이퍼텍스트(Hyper)** : 참조(하이퍼링크)를 통해 독자가 한 문서에서 다른 문서로 즉시 접근할 수 있는 텍스트

<br>

이러한 WWW를 구성하는 기술로서, 문서 기술 언어로는 SGML을 베이스로 한 HTML(HyperText Markup Language), 문서 전송 프로토콜로는 HTTP(HyperText Transfer Protocol), 문서의 주소를 지정하는 방법으로 URL(Uniform Resource Locator) 등 세 가지가 제안되었습니다.

> **SGML(Standard Generalized Markup Language)** : 문서용 마크업 언어를 정의하기 위한 메타 언어

<br>

WWW는 지금으로 말하자면 웹 브라우저, 그 당시에는 하이퍼텍스트를 열람할 수 있는 클라이언트 애플리케이션의 명칭이였다. 현재에는 이러한 일련의 시스템(구조)의 명칭으로 사용되어 WWW 혹은 단순히 웹(Web)이라 부른다.

<br>

### 1.2.2. 웹이 성장한 시대

### 1.2.3. 진보 안하는 HTTP

<br>

## 1.3. 네트워크의 기본은 TCP/IP

인터넷을 포함하여 일반적으로 사용하고 있는 네트워크는 TCP/IP라는 프로토콜에서 움직이고 있다. HTTP는 그 중 하나이다.

<br>

### 1.3.1. TCP/IP는 프로토콜의 집합

서로 다른 하드웨어와 운영체제 등을 가지고 서로 통신을 하기 위해서는 모든 요소에 규칙이 필요하게 된다. 이러한 규칙을을 **프로토콜** 이라고 부른다.

프로토콜에는 여러 가지가 있다. 케이블 규격이랑 IP 주소 지정 방법, 떨어진 상대를 찾기 위한 방법과 그 곳에 도달하는 순서, 그리고 웹을 표시하기 위한 순서 등 이다. 이렇게 인터넷과 관련된 프로토콜들을 모은 것을 TCP/IP 라고 부른다.

TCP와 IP 프로토콜을 가리켜 TCP/IP라고 부르기도 하지만, IP 프로토콜을 사용한 통신에서 사용되고 있는 프로토콜을 총칭해서 TCP/IP라고 부르기도 한다.

<br>

### 1.3.2. 계층으로 관리하는 TCP/IP

TCP/IP에서 중요한 개념 중 하나가 **계층(Layer)이다.** TCP/IP는 '애플리케이션 계층', '트랜스포트 계층', '데이터링크 계층', '링크 계층' 이렇게 4 계층으로 나뉘어 있다. 

각 계층은 계층이 연결되어 있는 부분만 결정되어 있어, 각 계층의 내부는 자유롭게 설계할 수 있다는 장점이 있다.

<br>

#### 애플리케이션 계층

애플리케이션 계층은 유저에게 제공되는 애플리케이션에서 사용하는 통신의 움직임을 결정한다.

FTP, DNS, HTTP 등이 이 계층에 포함된다.

> **FTP(File Transfer Protocol)** : 파일 전송 프로토콜. 서버와 클라이언트 사이의 파일 전송을 하기 위한 프로토콜
>
> **DNS(Domain Name System)** : 도메인 네임 시스템. 호스트의 도메인 이름을 호스트의 네트워크 주소로 바꾸거나 그 반대의 변환을 수행

<br>

#### 트랜스포트 계층

트랜스포트 계층은 애플리케이션 계층에 네트워크로 접속되어 있는 2대의 컴퓨터 사이의 데이터 흐름을 제공한다.

TCP, UDP 두 가지 프로토콜이 이에 해당한다.

> **TCP(Transmisson Control Protocol)** : 전송 제어 프로토콜. 인터넷에 연결된 컴퓨터에서 실행되는 프로그램 간에 데이터를 안정적으로, 순서대로, 에러없이 교환할 수 있게 한다.
>
> **UDP(User Datagram Protocol)** : 사용자 데이터그램 프로토콜. 인터넷에 연결된 컴퓨터와 단문 메시지를 교환하기 위해서 사용된다.

<br>

#### 네트워크 계층(혹은 인터넷 계층)

네트워크 계층은 네트워크 상에서 패킷의 이동을 다룬다. **패킷이란** 전송하는 데이터의 최소 단위이다. 이 계층에서는 어떠한 경로를 거쳐 상대의 컴퓨터까지 패킷을 보낼지를 결정한다.

<br>

#### 링크 계층(혹은 데이터 링크 계층, 네트워크 인터페이스 계층)

네트워크에 접속하는 하드웨어적인(케이블 등) 면을 다룬다.

<br>

### 1.3.3. TCP/IP 통신의 흐름

![image](https://user-images.githubusercontent.com/43431081/86423416-c7605500-bd1a-11ea-97bf-ae79b66e600b.png)

* TCP/IP로 통신을 할 때 계층을 순서대로 거쳐 상대와 통신한다.

<br>

![image](https://user-images.githubusercontent.com/43431081/86424133-a1d44b00-bd1c-11ea-93bb-fcdd922672c1.png)

* HTTP 통신(이더넷, LAN) 예시
  1. 클라이언트의 애플리케이션 계층(HTTP)에서 어느 웹 페이지를 보고 싶다라는 HTTP 리퀘스트 요청
  2. 트랜스포트 계층(TCP)에서는 애플리케이션 계층에서 받은 데이터(HTTP 메시지)를 통신하기 쉽게 조각내어 안내 번호와 포트 번호를 붙여 네트워크 계층에 전달
  3. 네트워크 계층(IP)에서는 수신지 MAC 주소를 추가해서 링크 계층에 전달
  4. 링크 계층을 통해 이더넷(LAN)으로 연결된 서버에게 데이터를 전송한다.
  5. 그 다음 순서대로 위의 계층에 전달하여 애플리케이션 계층까지 도달하게 된다.
* 이렇게 정보를 감싸는 것을 **캡슐화** 라고 부른다.

<br>

## 1.4. HTTP와 관계가 깊은 프로토콜은 IP/TCP/DNS

TCP/IP 중에서 HTTP와 관계가 깊은 IP, TCP, DNS 세 개의 프로토콜에 대해 살펴보자.

<br>

### 1.4.1. 배송을 담당하는 IP

IP(Internet Protocol)는 계층으로 말하자면 네트워크 층에 해당된다. 

IP의 역할은 패킷을 상대방에게 전달하는 것이다. 상대방에게 전달하기까지 여러 가지 요소가 필요하다. 그 중에서도 **IP 주소와 MAC(Medi Access Control Address) 주소** 필요하게 된다.

> 'IP' 와 'IP 주소' 에서 **'IP'는 프로토콜의 명칭이다.** 

IP 주소는 각 노드에 부여된 주소를 가리키고 MAC 주소는 각 네트워크 카드에 할당된 고유의 주소이다.

IP 주소는 임시적으로 다른 주체에 의해 할당 되는 것이지만, MAC 주소는 통신기기의 하드웨어 자체에 부여된 고유한 식별번호 이다.

그러므로 IP 주소는 변경 가능하지만 기본적으로 MAC 주소는 변경할 수 없다.

<br>

#### 통신은 ARP를 이용하여 MAC 주소에서 한다.

IP 통신은 MAC 주소에 의존해서 통신을 한다. 여러 대의 컴퓨터와 네트워크 기기를 중계해서 상대방에게 도착한다.

그렇게 중계하는 동안에는 다음으로 중계할 곳의 MAC 주소를 사용하여 목적지를 찾아간다. 이때, ARP(Address Resolution Protocol)이라는 프로토콜이 사용된다.

**ARP는 주소를 해결하기 위한 프로토콜 중 하나로, 수신자의 IP 주소를 바탕으로 MAC 주소를 조사할 수 있다.**

![image](https://user-images.githubusercontent.com/43431081/86427042-21b1e380-bd24-11ea-8c72-f7ff28bdf974.png)

<br>

![image](https://user-images.githubusercontent.com/43431081/86427069-30989600-bd24-11ea-87d2-97dfcdd54103.png)

<br>

#### 그 누구도 인터넷 전체를 파악하고 있지는 않다

컴퓨터와 라우터 등의 네트워크 기기는 목적지에 도착하기까지 대략적인 목적지만을 알고 데이터를 전송한다. 즉, 어떤 컴퓨터나 네트워크 기기도 인터넷 전체를 상세하게 파악하고 있지 못한다는 것이다. 이 시스템을 라우팅이라고 부른다.

<br>

### 1.4.2. 신뢰성을 담당하는 TCP

TCP(Transfer Control Protocol)는 계층으로 말하자면 트랜스포트 층에 해당하는데, 신뢰성 있는 바이트 스트림 서비스를 제공한다.

신뢰성 있는 서비스는 상대방에게 정확하게 데이터를 보내는 서비스를 의미한다.

바이트 스트림 서비스란 용량이 큰 데이터를 보내기 쉽게 TCP 세그먼트라고 불리는 단위 패킷으로 작게 분해하여 관리하는 것이다.

<br>

#### 상대에게 데이터를 확실하게 보내는 것이 일이다

상대에게 확실하게 데이터를 보내기 위해서 TCP는 **"쓰리웨이 핸드셰이킹(three way handshaking)"** 이라는 방법을 사용한다.

이 방법은 패킷을 보내고 잘 보내졌는지 여부를 상대에게 확인하는 방식이다.

이때 'SYN' 와 'ACK' 라는 TCP 플래그를 사용한다.

![image](https://user-images.githubusercontent.com/43431081/86427907-6b9bc900-bd26-11ea-8c86-ca4c937dc2c4.png)

1. 송신측에서 최초 'SYN' 플래그로 상대에게 접속함과 동시에 패킷을 보낸다.
2. 수신측에서는 'SYN/ACK' 플래그로 송신측에 접속함과 동시에 패킷을 수신했다고 알린다.
3. 송신측이 'ACK' 플래그를 보내 패킷 교환이 완료되었음을 알린다.

이 과정에서 어디선가 통신이 도중에 끊어지면 TCP는 다시 위의 과정을 거쳐 패킷을 재전송한다.

<br>

## 1.5. 이름 해결을 담당하는 DNS

**DNS(Domain Name System)는** HTTP와 같이 응용 계층 시스템에서 도메인 이름과 IP 주소 이름 확인을 제공한다. 

사람에게는 영어나 숫자 등으로 표기해 상대의 컴퓨터를 지정하는것이 친숙하기 때문에 IP 주소 대신 이름(도메인. ex."www.naver.com") 을 이용한다. 하지만 컴퓨터는 숫자가 더욱 친숙하다.

그래서 이 문제를 해결하기 위해 DNS가 존재한다. DNS는 도메인 명에서 IP 주소를 조사하거나 반대로 IP 주소로부터 도메인명을 조사하는 서비스를 제공한다.

![image](https://user-images.githubusercontent.com/43431081/86433657-4a42d900-bd36-11ea-9053-2a46dd500ff2.png)

<br>

## 1.6. 각각과 HTTP와의 관계

HTTP를 이용해 통신을 할 때 IP, TCP, DNS 가 어떤 역할을 하는지 살펴보자.

1. 클라이언트가 DNS에게 도메인 주소를 보내 IP 주소 변환 요청

   ![image](https://user-images.githubusercontent.com/43431081/86457526-c4875380-bd5e-11ea-8565-ab2f2adb6cb4.png)

2. HTTP 메시지 작성(어플리케이션 계층)

   ![image](https://user-images.githubusercontent.com/43431081/86457489-b6393780-bd5e-11ea-8705-bf83c4b3b153.png)

3. TCP(트랜스포트 계층)를 통해 HTTP 메시지 패킷 분해 및 전송

   ![image](https://user-images.githubusercontent.com/43431081/86457616-e680d600-bd5e-11ea-8df7-ad79622f830d.png)

4. IP(네트워크 계층)를 통해 수신측이 어디에 있는지 중계해 가면서 배송

   ![image](https://user-images.githubusercontent.com/43431081/86457636-eed91100-bd5e-11ea-8782-59d36df76139.png)

5. TCP를 통해 수신측에서 패킷을 수신

   ![image](https://user-images.githubusercontent.com/43431081/86457898-555e2f00-bd5f-11ea-8b13-b72f0831f83b.png)

6. HTTP를 통해 수신측이 리퀘스트 내용을 처리

   ![image](https://user-images.githubusercontent.com/43431081/86457921-5beca680-bd5f-11ea-8b01-be6d83299d6d.png)

> 리퀘스트 처리 결과도 마찬가지로 TCP/IP 통신 순서대로 클라이언트에 반환

<br>

## 1.7. URI와 URL

웹 브라우저 등으로 웹 페이지를 표시하기 위해 입력하는 주소가 바로 URL 이다.

> ex) https://www.google.co.kr

<br>

### 1.7.1. URI는 리소스 식별자

**URI는 Uniform Resource Identifiers** 의 약자이다.

* **Uniform**
  * 통일(Uniformity)된 서식을 결정
    * ex) `URI = scheme:[//authority]path[?query][#fragment]`
    * https://www.google.co.kr
* **Resource**
  * 식별 가능한 모든 것
  * 도큐먼트 파일뿐만 아니라 이미지와 서비스 등 다른 것과 구별할 수 있는 것
* **Identifier**
  * 식별 가능한 것을 참조하는 오브젝트이며 식별자로 불린다.

<br>

URI는 리소스를 식별하기 위해 문자열 전반을 나타내는데 비해 URL은 리소스의 장소(네트워크 상의 위치)를 나타낸다. URL은 URI의 서브셋이다. `URI 예시: ex) http://www.ietf.org/rfc/rfc2396.txt`

<br>

### 1.7.2. URL 포맷

* **URI**

  * 정보 전체를 지정하는 완전 수식 절대 URI, 완전 수식 절대 URL

    ![image](https://user-images.githubusercontent.com/43431081/86463060-c0abff00-bd67-11ea-9cb8-63c19d682d43.png)

    * **스키마**
      * 'http:', 'https:' 같은 스키마를 사용하여 리소스를 얻기 위해 사용하는 프로토콜을 지시
      * 대문자와 소문자는 무시되고 마지막에 콜론( : )이 하나 붙는다.
      * "data:" 와 "javascript:" 같이 데이터와 프로그램을 지정할 수도 있다.
    * **자격정보(크리덴셜)**
      * 서버로부터 리소스를 취득하려면 자격정보(크리덴셜)가 필요하다. 유저명과 패스워드를 지정할 수 있다.
      * 옵션이다.
    * **서버 주소**
      * 완전 수식 형식인 URI 에서는 서버 주소를 지정할 필요가 있다.
    * **계층적 파일 패스**
      * 특정 리소스를 식별하기 위해서 서버 상의 파일 패스를 지정한다.
    * **쿼리 문자열**
      * 파일 패스로 지정된 리소스에 임의의 파라미터를 넘겨주기 위한 것
      * 옵션이다.
    * **프래그먼트 식별자**
      * 취득한 리소스에서 서브 리소스를 가리키기 위해서 프래그먼트 식별자가 사용된다.
      * 옵션이다.

  * 상대 URL