# CHAPTER 02. 간단한 프로토콜 HTTP

HTTP 프로토콜의 구조에 대해 설명한다.

<br>

## 2.1. HTTP는 클라이언트와 서버 간에 통신을 한다

HTTP는 클라이언트와 서버 간에 통신을 한다. 텍스트와 이미지 등과 같은 리소스를 필요하다고 요구하는 쪽이 클라이언트가 되고, 이러한 리소스를 제공하는 쪽이 서버가 된다.

![image](https://user-images.githubusercontent.com/43431081/86482060-23af8d00-bd8c-11ea-9913-497ac50c298f.png)

* HTTP를 사용하여 2대의 컴퓨터 간에 통신을 하는 경우, 한 번 통신을 할 때 마다 반드시 어느 한 쪽은 클라이언트가 되고 다른 한 쪽은 서버가 된다.
* 즉, HTTP는 클라이언트와 서버의 역햘을 명확하게 구별하고 있다.

<br>

## 2.2. 리퀘스트와 리스폰스를 교환하여 성립

![image](https://user-images.githubusercontent.com/43431081/86482302-a59fb600-bd8c-11ea-98a1-5ad2efa8035a.png)

* HTTP는 클라이언트로부터 리퀘스트(요청, Request)가 송신되며, 그 결과가 서버로부터 리스폰스(응답, Response)로 되돌아온다.
* 즉, 반드시 클라이언트측으로부터 통신이 시작되며 서버 측은 리퀘스트를 수신하지 않으면 리스폰스가 발생하는 경우가 없다.

<br>

![image](https://user-images.githubusercontent.com/43431081/86482703-72a9f200-bd8d-11ea-9859-4604b12ad7aa.png)

* **클라이언트 측 HTTP 리퀘스트 내용**

  ```http
  GET /index.html HTTP /1.1
  Host: www.naver.com
  ```

  * **"GET"** : 메소드. 서버에 요구하는 종류
  * **"/index.html"** : URI. 요구 대상인 리소스
  * **"HTTP/1.1"** : 클라이언트 기능을 식별하기 위한 HTTP 버전 번호

  > HTTP 서버 상에 있는 /index.html 리소스가 필요하다는 리퀘스트

<br>

리퀘스트 메시지는 `메소드` , `URI` , `프로토콜 버전` , `옵션 리퀘스트 헤더 필드` 와 `엔티티` 로 구성된다.

```http
POST /form/entry HTTP/1.1
Host: www.naver.com
Connection: keep-alive
Content-Type: application/x-www-form-urlencoded
Content-Length: 16

name=ueno&age=37
```

* **POST** : 메소드
* **/form/entry** : URI
* **HTTP/1.1** : 프로토콜 버전
* **Host, Connection, Content-Type, Content-Length** : 리퀘스트 헤더 필드
* **name=ueno&age=37** : 엔티티

<br>

* **서버 측 HTTP 응답** : `프로토콜 버전` , `상태 코드` , `상태 코드 설명` , `리스폰스 헤더 필드` , `바디` 로 구성된다.

  ```http
  HTTP/1.1 200 OK
  Date: Tue, 10 Jul 2012 06:50:15 GMT
  Content-Length: 362
  Content-Type: text/html
  
  <html>
  ...
  ```

  * **HTTP /1.1** : 서버의 HTTP 버전
  * **200 OK** : 리퀘스트의 처리 결과를 나타내는 상태 코드와 설명
  * **Content-Length, Content-Type** : 헤더 필드
  * **\<html> ... (빈 줄 아래의 내용들)** : 바디(body)

<br>

## 2.3. HTTP는 상태를 유지하지 않는 프로토콜

HTTP는 상태를 계속 유지하지 않는 **스테이트리스(stateless)** 프로토콜이다. 즉, HTTP 프로토콜 레벨에서는 **이전에 보냈던 리퀘스트나** 이미 되돌려준 **리스폰스에 대해서는 전혀 기억하지 않는다.**

그러므로 HTTP에서는 리퀘스트나 리스폰스가 보내질 때 마다 **매번 새롭게 연결을 하고 데이터 전송이 끝나면 연결을 끊는다.** 이렇게 설계된 이유는 수십만명이 웹 서비스를 사용하더라도 접속유지를 최소한으로 처리할 수 있게 되어, 많은 데이터를 매우 빠르고 확실하게 처리하는 **범위성(scalability)을** 확보할 수 있다.

그러나 웹이 진화하여 무상태 특성만으로는 처리하기 어려운 일이 생기게 되었다. 예를 들면, 쇼핑 사이트에 로그인했을 경우이다. 이때는 다른 페이지로 이동하더라도 **로그인 상태를 유지할 필요가 있다.** 이를 위해서는 누가 어떤 리퀘스트를 보냈는지를 파악하기 위해 상태를 유지할 필요가 있다. 

HTTP/1.1은 상태를 유지하지 않는 프로토콜이다. 그래서 상태를 계속 유지하고 싶은 요구에 부응하기 위해서 **쿠키(Cookie)라는** 기술이 도입되었다.

<br>

## 2.4. 리퀘스트 URI로 리소스를 식별

HTTP는 클라이언트가 URI(Uniform Resource Identifiers)를 사용하여 인터넷 상의 리소스를 지정한다.

![image](https://user-images.githubusercontent.com/43431081/86545495-6464fd00-bf6a-11ea-87e1-e8e06550bcc6.png)

> 클라이언트가 리소스를 호출하기 위해서 리퀘스트를 송신할 때 리퀘스트 URI 라고 불리는 형식을 지켜야 한다.

<br>

**리퀘스트 URI 지정 방법들**

* *모든 URI를 리퀘스트 URI에 포함한다.*

  ```http
  GET http://www.naver.com/index.html HTTP/1.1
  ```

* *Host 헤더 필드에 네트워크 로케이션을 포함한다.*

  ```http
  GET /index.html HTTP/1.1
  Host: www.naver.com
  ```

* *특정 리소스가 아닌 서버 자신에게 리퀘스트를 송신하는 경우*

  ```http
  OPTIONS * HTTP/1.1
  ```

  > HTTP 서버가 지원하고 있는 메소드를 묻는 예시이다.

<br>

## 2.5. 서버에 임무를 부여하는 HTTP 메소드

HTTP/1.1 에서 사용할 수 있는 메소드에 대해서 알아보자.

<br>

### GET: 리소스 획득

GET 메소드는 리퀘스트 URI로 식별된 리소스를 가져올 수 있도록 요구한다.

<br>

*GET 메소드를 사용한 리퀘스트/리스폰스 예*

| 리퀘스트                                           | 리스폰스                        |
| -------------------------------------------------- | ------------------------------- |
| GET /index.html HTTP /1.1<br />Host: www.naver.com | index.html 리소스를 되돌려준다. |

<br>

### POST: 엔티티 전송

POST 메소드는 엔티티를 전송하기 위해서 사용된다.

<br>

*POST 메소드를 사용한 리퀘스트/리스폰스 예*

| 리퀘스트                                                     | 리스폰스                                                |
| ------------------------------------------------------------ | ------------------------------------------------------- |
| POST /submit.cgi HTTP /1.1<br />Host: www.naver.com<br />Content-Length: 1560(1560바이트 데이터) | submit.cgi 가 수신한 데이터의 처리한 결과를 되돌려준다. |

<br>

### PUT: 파일 전송

PUT 메소드는 파일을 전송하기 위해서 사용된다. 리퀘스트 중에 포함된 엔티티를 리퀘스트 URI로 지정한 곳에 보존하도록 요구한다.

HTTP/1.1 PUT 자체에는 인증 기능이 없어 누구든지 파일을 업로드가 가능하여 보통 웹 애플리케이션 등에 의한 인증 기능과 함께 구현을 한다.

<br>

*PUT 메소드를 사용한 리퀘스트/리스폰스 예*

| 리퀘스트                                                     | 리스폰스                                                     |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| PUT /example.html HTTP /1.1<br />Host: www.naver.com<br />Content-Type: text/html<br />Content-Length: 1560(1560 바이트 데이터) | 상태 코드 204 No Content <br />리스폰스를 되돌려준다(서버 상에 example.html이 이미 존재할 경우). |

<br>

### HEAD: 메시지 헤더 취득

HEAD 메소드는 GET과 같은 기능이지만 메시지 바디는 돌려주지 않는다.

URI 유효성과 리소스 갱싱 시간을 확인하는 목적 등으로 사용된다.

<br>

*HEAD 메소드를 사용한 리퀘스트/리스폰스 예*

| 리퀘스트                                            | 리스폰스                                        |
| --------------------------------------------------- | ----------------------------------------------- |
| HEAD /index.html HTTP /1.1<br />Host: www.naver.com | index.html에 관련된 리스폰스 헤더를 되돌려준다. |

<br>

### DELETE: 파일 삭제

DELETE 메소드는 파일을 삭제하기 위해 사용된다. 이것 또한 인증 기능이 없기 때문에 웹 애플리케이션의 인증 기능과 함께 사용된다.

<br>

*DELETE 메소드를 사용한 리퀘스트/리스폰스 예*

| 리퀘스트                       | 리스폰스                                                     |
| ------------------------------ | ------------------------------------------------------------ |
| DELETE /example.html HTTP /1.1 | 상태 코드 204 No Content의<br />리스폰스를 되돌려준다.<br />(example.html은 이미 서버상에서 삭제되어 있을 경우) |

<br>

### OPTIONS: 제공하고 있는 메소드의 문의

OPTIONS 메소드는 리퀘스트 URI로 지정한 리소스가 제공하고 있는 메소드를 조사하기 위해 사용된다.

<br>

*OPTIONS 메소드를 사용한 리퀘스트/리스폰스 예*

| 리퀘스트                                     | 리스폰스                                                     |
| -------------------------------------------- | ------------------------------------------------------------ |
| OPTIONS * HTTP /1.1<br />Host: www.naver.com | HTTP /1.1 200 OK<br />Allow: GET, POST, HEAD, OPTIONS<br />(서버가 제공하고 있는 메소드를 되돌려준다.) |

<br>

### TRACE: 경로 조사

TRACE 메소드는 Web 서버에 접속해서 자신에게 통신을 되돌려 받는 루프백(loop-back)을 발생시킨다.

리퀘스트를 보낼 때에 "Max-Forwards" 라는 헤더 필드에 수치를 포함시켜 서버를 통과할 때마다 그 수치를 줄여간다.

수치가 0이 된 곳을 끝으로, 리퀘스트를 마지막으로 수신한 곳에서 상태 코드 200 OK 리스폰스를 되돌려 준다.

![image](https://user-images.githubusercontent.com/43431081/86548482-84e78400-bf77-11ea-9862-623d546d57f9.png)

> **프록시 서버** : 클라이언트가 자신을 통해서 다른 네트워크 서비스에 간접적으로 접속할 수 있게 해 주는 컴퓨터 시스템이나 응용 프로그램을 가리킨다.

<br>

*TRACE 메소드를 사용한 리퀘스트/리스폰스 예*

| 리퀘스트                                                     | 리스폰스                                                     |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| TRACE / HTTP /1.1<br />Host: www.naver.com<br />Max-Forwards: 2 | HTTP /1.1 200 OK<br />Content-Type: message/http<br />Content-Length: 1024<br /><br />TRACE / HTTP /1.1<br />Host: www.naver.com<br />Max-Forwards: 2 (리퀘스트 내용을 리스폰스에 포함해서 되돌려준다) |

> TRACE 메소드는 보안 상의 문제가 있기 때문에 보통은 사용되고 있지 않다.

<br>

### CONNECT: 프록시에 터널링 요구

CONNECT 메소드는 프록시에 터널 접속 확립을 요함으로써, TCP 통신을 터널링 시키기 위해서 사용된다.

![image](https://user-images.githubusercontent.com/43431081/86549365-659e2600-bf7a-11ea-8e5e-ef70d4042f54.png)

* Client가 Proxy를 통해서 Server와 SSL(HTTPS) 통신을 하고자 할 때 사용된다.
* 이때 Proxy는 데이터 전달 역할만 수행하여 proxy는 데이터를 검사할 수 없어, end-to-end 보안이 보장된다.

<br>

*CONNECT 메소드를 사용한 리퀘스트/리스폰스*

| 리퀘스트                                                     | 리스폰스                                      |
| ------------------------------------------------------------ | --------------------------------------------- |
| CONNECT proxy.naver.com:8080 HTTP /1.1<br />Host: proxy.naver.com | HTTP /1.1 200 OK<br />(그 뒤에 터널링을 개시) |

> **CONNECT 메소드 양식**
>
> `CONNECT 프록시 서버 : 포트 HTTP 버전`

<br>

## 2.6. 메소드를 사용해서 지시를 내리다

| 메소드  |             설명             | 제공하고 있는 HTTP 버전 |
| :-----: | :--------------------------: | :---------------------: |
|   GET   |         리소스 취득          |        1.0, 1.1         |
|  POST   |       엔티티 바디 전송       |        1.0, 1.1         |
|   PUT   |          파일 전송           |        1.0, 1.1         |
|  HEAD   |       메시지 헤더 취득       |        1.0, 1.1         |
| DELETE  |          파일 삭제           |        1.0, 1.1         |
| OPTIONS | 서포트하고 있는 메소드 문의  |           1.1           |
|  TRACE  |          경로 조사           |           1.1           |
| CONNECT |    프록시에의 터널링 요구    |           1.1           |
|  LINK   | 리소스 간에 링크 관계를 확립 |           1.0           |
| UNLINK  |        링크 관계 삭제        |           1.0           |

<br>

## 2.7 지속 연결로 접속량을 절약

HTTP 초기 버전에서는 HTTP 통신을 한 번 할 때마다 TCP를 매번 연결하고 종료하는 과정이 필요했다.

![image](https://user-images.githubusercontent.com/43431081/86550328-0db4ee80-bf7d-11ea-8119-db0813fa7cf8.png)

* 초기 당시의 통신에서는 전송되는 데이터의 사이즈가 매우 작았으나, 현재는 다량의 이미지를 포함한 문서를 전송하게 되어 매번 TCP 연결과 종료를 하면 쓸모없는 일이 발생되어 통신량이 늘어나게 됬었다.

<br>

### 2.7.1 지속 연결

HTTP/1.1 와 일부 HTTP/1.0 에서는 TCP 연결 문제를 해결하기 위해서 지속 연결(Persistent Connections)이라는 방법을 고안하였다. 

지속 연결의 특징은 어느 한 쪽이 명시적으로 연결을 종료하지 않는 이상 TCP 연결을 계속 유지한다.

![image](https://user-images.githubusercontent.com/43431081/86556121-5c6a8480-bf8d-11ea-9573-98bfb774e70f.png)

* 지속 연결은 1회의 TCP 커넥션 연결로 리퀘스트와 리스폰스 교환을 여러 번 한다. 그러므로 커넥션 연결로 인한 오버헤드가 줄어든다.

<br>

### 2.7.2. 파이프라인화

지속 연결은 여러 리퀘스트를 보낼 수 있도록 파이프라인(HTTP pipelining)화를 가능하게 한다.

![image-20200706134255728](../../Library/Application Support/typora-user-images/image-20200706134255728.png)

* 이전에는 리퀘스트 송신 후에 리스폰스를 수신할 때까지 기다렸으나, 파이프라인화를 통해 리스폰스를 기다리지 않고 바로 다음 리퀘스트를 보낼 수 있게 되었다.

<br>

## 2.8. 쿠키를 사용한 상태 관리

인증이 필요한 웹 페이지에서 상태 관리를 하지 않는다면 새로운 페이지로 이동할 때마다 재차 로그인 정보를 보내든지 리퀘스트마다 매개 변수나 추가 정보를 붙여서 로그인 상태를 관리해야 하는 상황이 발생한다.

이와 같은 문제를 해결하기 위해 HTTP 특징인 스테이트리스(stateless)를 남겨둔 채 쿠키라는 시스템이 도입되었다.

* **쿠키를 가지지 않은 상태에서의 리퀘스트**

  ![image](https://user-images.githubusercontent.com/43431081/86557341-d18b8900-bf90-11ea-9f24-8506c776eb86.png)

  * 쿠키는 서버에서 리스폰스로 보내진 Set-Cookie라는 헤더 필드에 의해 쿠키를 클라이언트에 보존하게 된다.

* **2회째 이후(쿠키를 가지고 있는 상태)의 리퀘스트**

  ![image](https://user-images.githubusercontent.com/43431081/86557356-d7816a00-bf90-11ea-9076-1c6b1433b2fd.png)

  * 다음 번에 클라이언트가 같은 서버로 리퀘스트를 보낼 때, 자동으로 쿠키 값을 넣어서 송신한다.
  * 서버는 클라이언트가 보내온 쿠키를 확인해서 어느 클라이언트가 접속했는지 체크하고 서버 상의 기록을 확인해서 이전 상태를 알 수 있다.

<br>

*쿠키 교환 예시*

1. **리퀘스트(쿠키를 가지고 있지 않은 상태)**

   ```http
   GET /reader/ HTTP /1.1
   Host: www.naver.com
   ```

   > 헤더 필드에 쿠키는 없다.

2. **리스폰스(서버가 쿠키를 발행)**

   ```http
   HTTP /1.1 200 OK
   Date: Thu, 12 Jul 2012 07:12:20 GMT
   Server: Apache
   <Set-Cookie: sid=345678909876; path=/; expires=Wed, => 10-Oct-12 07:12:20 GMT>
   Content-Type: text/plain; charset=UTF-8
   ```

3. **리퀘스트(보관하고 있던 쿠키를 자동 송신)**

   ```http
   GET /image/ HTTP /1.1
   Host: www.naver.com
   Cookie: sid=345678909876
   ```